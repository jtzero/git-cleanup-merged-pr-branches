#!/usr/bin/env bash
#
# reqs: realpath
# TODO pass GCMPB_VERBOSE around instead of global
#set -Eeuo pipefail
if [ -z "${BASH_SOURCE[0]:-}" ]; then
  # zsh
  GCMPB_DIR="${0:A:h}"
  # shellcheck disable=SC2034
  IS_ZSH=1
else
  if ! command -v realpath >/dev/null 2>&1; then
    exit 1
  fi
  GCMPB_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
  # shellcheck disable=SC2034
  IS_BASH=1
fi

RED=$'\e[0;31m'
YELLOW=$'\e[1;33m'
CLEAR_COLOR=$'\e[0m'

printerr() { printf "\033[0;31m%s\033[0m\n" "$*" >&2; }
printverbose() {
  local verbose="${1}"
  local rest="${*:2}"
  if [ "${verbose}" = 'true' ]; then
    printf "\n\033[0;93m%s\033[0m\n" "${rest}" >&2
  fi
}

config_file_path() {
  printf '%s' "$(git rev-parse --show-toplevel)/.git/info/cleanup"
}

config() {
  local -r config_filepath="$(config_file_path)"
  if [ -f "${config_filepath}" ]; then
    # shellcheck disable=SC2086
    cat ${config_filepath}
  else
    printf ''
  fi
}

excluded_by_config() {
  (config | grep 'exclude=' || [[ $? == 1 ]]) | cut -d'=' -f2
}

get_branches() {
  local config_exclusions="${1:-}"
  local -r current_branch="$(git branch --show-current)"
  local -r current_remote_branch_parse="$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>&1)"
  if [[ "${current_remote_branch_parse}" == "fatal: no upstream configured for branch"* ]]; then
    local current_branch_with_remote=""
  else
    local current_branch_with_remote="${current_remote_branch_parse}:${current_branch}"
  fi
  local -r default_remote="$(git remote | head -n1)"
  local -r default_branch="$(git ls-remote --symref "${default_remote}" HEAD | grep 'ref' | cut -d'/' -f3 | cut -d$'\t' -f1)"

  if [ "${config_exclusions}" = "" ]; then
    config_exclusions=" "
  fi

  local -r branches_to_check="$(git for-each-ref --format='%(upstream:short):%(refname:short)' refs/heads/ | grep -Ev '^:' | grep -v "${current_branch_with_remote}" |
    grep -v "${default_remote}/${default_branch}" | grep -v -E "${config_exclusions}")"
  printf '%s\n' "${branches_to_check}"
}

join_by() {
  local d=${1-} f=${2-}
  printf %s "${f//$'\n'/$d}"
}

available_platforms() {
  local dir="${1}"
  printf "%s" "$(join_by '|' "$(find "${dir}" -mindepth 1 -maxdepth 1 -exec basename {} \; | cut -d '.' -f1)")"
}

# TODO be more strict about url parsing
query_vcs_platform() {
  local -r remote="${1}"
  local -r platforms_available="${2}"
  local -r platform="$(git remote -v | grep 'push' | grep -E "^${remote}" | cut -d$'\t' -f2- | grep -o -E "${platforms_available}" | head -n1)"
  if [ -z "${platform}" ]; then
    # shellcheck disable=SC2016
    printf '%s:%s' 'not_found:platform not found from `git remote -v`' "${platforms_available}"
  else
    printf '%s' "found:${platform}"
  fi
}

spin() {
  local empty_or_message="${1:-}"
  local -r spinner='⣾⣽⣻⢿⡿⣟⣯⣷'
  local -r charwidth=1

  local message=""
  if [ -n "${empty_or_message}" ]; then
    message="${empty_or_message} "
  fi

  local i=0
  while true; do
    i=$(((i + 1) % ${#spinner}))
    printf "\r%s" "${message}${spinner:$i:$charwidth} "
    sleep 0.1
  done
}

kill_spinner_if_running() {
  local spinner_pid="${1}"
  if kill -s 0 "${spinner_pid}" >/dev/null 2>&1; then
    kill "${spinner_pid}" >/dev/null 2>&1
  fi
}

clean_pr_merged_branches() {
  local branches_to_check="${1}"
  local auto_apply="${2:-false}"
  local verbose="${3:-}"
  local spinner="${4:-true}"
  local toDelete=()
  local dangling=()
  local -r platforms_available="$(available_platforms "${GCMPB_DIR}/platforms")"
  local spinner_pid=""
  if [ "${spinner}" = "true" ]; then
    (
      set +x
      spin 'checking for dead branches'
    ) &
    spinner_pid=$!
    # shellcheck disable=SC2064
    trap "kill_spinner_if_running '${spinner_pid}'" EXIT
  fi
  for remote_name in $(printf '%s' "${branches_to_check}" | cut -d '/' -f1 | uniq); do
    local remote_group='' platform_query_result='' platform='' platform_query_discrete='' platform_loaded=''
    remote_group="$(printf '%s' "${branches_to_check}" | grep "^${remote_name}")"
    platform_query_result="$(query_vcs_platform "${remote_name}" "${platforms_available}")"

    platform_query_discrete="$(cut -d':' -f1 <<<"${platform_query_result}")"
    if [ "${platform_query_discrete}" = "not_found" ]; then
      kill_spinner_if_running "${spinner_pid}"
      printf '%s\n%s' "${platform} in ${GCMPB_DIR}/platforms/" "$(ls "${GCMPB_DIR}/platforms/")"
      exit 22
    fi

    platform="$(cut -d':' -f2 <<<"${platform_query_result}")"
    local platform_path="${GCMPB_DIR}/platforms/${platform}.sh"
    if [ "${platform_loaded}" != "${platform}" ]; then
      platform_loaded="${platform}"
    fi

    decisions="$(
      #shellcheck source=/dev/null
      . "${platform_path}"

      for remote_branch_and_local_branch in $remote_group; do
        local remote_branch='' local_branch='' platform_query_result='' platform='' decision='' decision_command='' decision_message_and_rest=''
        remote_branch="$(echo "${remote_branch_and_local_branch}" | cut -d':' -f1)"
        local_branch="$(echo "${remote_branch_and_local_branch}" | cut -d':' -f2)"

        decided="$(decide "${local_branch}" "${remote_branch}" "${spinner_pid}" "${verbose}")"
        printf '%s\n' "$(printf '%s' "${decided}" | base64 -w 0)"
      done
    )"
    for base64_decision in ${decisions}; do
      local decision='' local_branch=''
      decision="$(base64 -d <<<"${base64_decision}")"
      local_branch="$(printf '%s' "${decision}" | cut -d':' -f2 -z | tr -d '\0')"
      decision_message_and_rest="$(parse_decision_message_and_rest "${decision}")"
      printverbose "${verbose}" "${decision}"
      decision_command="$(printf '%s' "${decision}" | cut -d':' -f1 -z | tr -d '\0')"
      if [ "${decision_command}" = "${DECIDE_DELETE}" ]; then
        toDelete[${#toDelete[@]}]="${local_branch}"

      elif [ "${decision_command}" = "${DECIDE_WARNING_DELETED_ON_REMOTE}" ]; then
        dangling[${#dangling[@]}]="${local_branch}"
      fi
    done
  done

  if [ ${#toDelete[@]} -gt 0 ] || [ ${#dangling[@]} -gt 0 ]; then
    kill_spinner_if_running "${spinner_pid}"
    printf '\n%s\n' '==='
    printf '%s\n' "${RED}The following had PR's and can be deleted"
    if [ ${#toDelete[@]} -gt 0 ]; then
      printf '%s' "- "
      array_join '\n- ' "${toDelete[@]}"
      printf '\n'
    fi
    if [ -n "$(git remote prune origin -n)" ]; then
      printf '%s\n' "- Prune tracking branches"
      prune_tracking
    fi
    printf '%s' "${CLEAR_COLOR}"
    if [ ${#dangling[@]} -gt 0 ]; then
      printf '%s\n' "${YELLOW}The following were deleted on remote, but did not have a pr and will only be deleted if 'i' is entered"
      printf '%s' '~ '
      array_join '\n~ ' "${dangling[@]}"
      printf '%s\n' "${CLEAR_COLOR}"
    fi
    interactive_delete "${auto_apply}" "${toDelete[@]}" "|" "${dangling[@]}"
  else
    kill_spinner_if_running "${spinner_pid}"
  fi
}

parse_decision_message_and_rest() {
  local decision="${1}"
  printf '%s' "${decision}" | cut -d':' -f3-
}

DECIDE_DELETE='delete'
DECIDE_WARNING_DELETED_ON_REMOTE='warning_deleted_on_remote'
DECIDE_SKIP='skip'

decide() {
  local -r local_branch="${1}"
  local -r remote_branch="${2}"
  local -r spinner_pid="${3}"
  local -r verbose="${4:-false}"

  local -r type_result="$(type pre_init_hook 2>&1)"
  if ! (printf '%s' "${type_result}" | grep -sq 'not found'); then
    pre_init_hook "${spinner_pid}"
  fi

  states="$(get_states "${remote_branch}")"

  had_a_pr="$(printf '%s\n' "${states}" | jq '. | length > 0')"
  if [ "${had_a_pr}" = "true" ]; then
    local any_open_statuses=""
    any_open_statuses="$(get_any_open_states "${states}")"
    if [ "${any_open_statuses}" = "false" ]; then
      local only_completed=""
      only_completed="$(get_only_completed "${states}")"
      if [ "${only_completed}" = "true" ]; then
        printf '%s:%s:%s:%s' "${DECIDE_DELETE}" "${local_branch}" "${local_branch}->${remote_branch} had a pr that completed" "${states}"
      else
        printf '%s:%s:%s:%s' "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} has a pr that is not marked as ${COMPLETED_STATES}, not deleting" "${states}"
      fi
    else
      printf '%s:%s:%s:%s' "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} has open pr's, not deleting" "${states}"
    fi
  else
    local deleted_remotely="false"
    local -r remotely_deleted_type_result="$(type branch_was_deleted_remotely 2>&1)"
    if ! (printf '%s' "${remotely_deleted_type_result}" | grep -sq 'not found'); then
      deleted_remotely="$(branch_was_deleted_remotely "${remote_branch}")"
    fi
    if [ "${deleted_remotely}" = "true" ]; then
      printf '%s:%s::%s:%s' "${DECIDE_WARNING_DELETED_ON_REMOTE}" "${local_branch}" "${local_branch}->${remote_branch} never had a pr, but was deleted on remote" "${states}"
    else
      printf '%s:%s:%s:%s' "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} never had a pr, not deleting" "${states}"
    fi
  fi
}

array_join() {
  local -r delimiter="${1}"
  local array=("${@:2}")
  if [ ${#array[@]} -gt 1 ]; then
    for item in "${array[@]}"; do
      printf "%s${delimiter}" "${item}"
    done
  else
    printf '%s' "${array[0]}"
  fi
}

ask() {
  local question="${1}"
  local apply='n'
  exec </dev/tty
  if [ "${ZSH:-}" ]; then
    # shellcheck disable=SC2229
    read -r "?${question}" apply
  else
    read -rp "${question}" apply
  fi
  printf "%s" "${apply}"
}

interactive_delete() {
  local -r auto_apply="${1}"
  local items=("${@:2}")
  local index=0
  for item in "${items[@]}"; do
    if [ "${item}" == "|" ]; then
      break
    fi
    ((++index))
  done

  local -r toDelete=("${items[@]:0:$index}")
  local -r dangling=("${items[@]:(($index + 1))}")

  local apply='n'
  local -r verbose="${GCMPB_VERBOSE:-}"
  if [ "${auto_apply}" = "true" ]; then
    apply='y'
  else
    apply="$(ask 'apply changes? (y/n/p/i) ')"
  fi
  if [ "${apply}" = "y" ]; then
    if [ "${#toDelete[@]}" -gt 0 ]; then
      delete_branches "$(echo "${toDelete[@]}" | tr "\n" " " | tr -s " ")"
    fi
    if [ -z "$(git remote prune origin -n)" ]; then
      prune_tracking
    fi
  elif [ "${apply}" = "i" ]; then
    delete_branches "$(echo "${toDelete[@]}" "${dangling[@]}" | tr "\n" " " | tr -s " ")"
  elif [ "${apply}" = "p" ]; then
    for branch in "${items[@]}"; do
      local should_delete='n'
      should_delete="$(ask "${branch}:delete? (y/n)")"
      if [ "${should_delete}" = "y" ]; then
        delete_branches "${branch}"
      else
        printverbose "${verbose}" "not deleting...${branch}"
      fi
    done
    interactive_prune_tracking "${verbose}"
  fi
}

interactive_prune_tracking() {
  local -r verbose="${1}"
  local -r prune="$(ask "prune tracking? (y/n)")"
  if [ "${prune}" = 'y' ]; then
    prune_tracking
  else
    if [ "${verbose}" = "true" ]; then
      printf '%s\n' "not deleting...${branch}"
    fi
  fi
}

prune_tracking() {
  git remote prune "$(git remote -v | cut -d$'\t' -f1 | uniq)" | grep -E '^\s\*'
}

delete_branches() {
  local toDelete=("$@")
  # shellcheck disable=SC2068
  git branch -D ${toDelete[@]}
}

interactive_help() {
  # shellcheck disable=SC2006
  cat <<-'EOS'
  Interactive options: (case sensitive)
    y: yes
    n: no
    i: include dangling
    p: partial, same as in `git add -p` https://git-scm.com/docs/git-add#Documentation/git-add.txt--p
    h: print this help
EOS
}

default_usage_string() {
  cat <<-'EOS'
usage: git-cleanup-merged-pr-branches $PREVIOUS_SHA $NEXT_SHA $BRANCHES_OR_FILES | git-cleanup-merged-pr-branches help'
    All arguments are required however the first two can be empty strings.
    "...the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0)."
    Further explanation of arguments is here https://git-scm.com/docs/githooks#_post_checkout
EOS
}

standalone_usage_string() {
  printf "%s\n" "usage: git-cleanup-merged-pr-branches |  git-cleanup-merged-pr-branches help|--help|?|--?"
}

help() {
  local -r standalone="${1:-false}"
  if [ "${standalone}" = "true" ]; then
    standalone_usage_string
  else
    default_usage_string
  fi
  interactive_help
  cat <<-'EOS'
  Variables:
  SKIP_CLEANUP_MERGED_PR_BRANCHES: if set to true this script will skip execution
    GCMPB_VERBOSE: if set to true this script will print more information as it runs
EOS
}

run() {
  local branch_or_files="${1}"
  local config_exclusions="${2}"
  local auto_apply="${3:-false}"
  local skip_cleanup_merged_pr_branches="${4:-false}"
  local verbose="${5:-false}"
  local spinner="${6:-true}"
  local interactive_rebase_in_progress=false

  if find -L "$(git rev-parse --git-dir)" -mindepth 1 | grep -iE 'rebase.*interactive' >/dev/null 2>&1; then
    interactive_rebase_in_progress=true
  fi

  if [ "${config_exclusions}" != "" ]; then
    printverbose "${verbose}" "items excluded via config($(config_file_path)):${config_exclusions}:"
  fi
  if [ "${skip_cleanup_merged_pr_branches}" = "false" ] && [ "${branch_or_files}" = "1" ] && [ "${interactive_rebase_in_progress}" = "false" ]; then
    clean_pr_merged_branches "$(get_branches "${config_exclusions}")" "${auto_apply}" "${verbose}" "${spinner}"
  else
    printverbose "${verbose}" "skipping clean_pr_merged_branches due to \$SKIP_CLEANUP_MERGED_PR_BRANCHES:${skip_cleanup_merged_pr_branches:-} or \$BRANCH_OR_FILES == 0:${branch_or_files} or interactive rebase in progress:${interactive_rebase_in_progress}"
  fi
}
