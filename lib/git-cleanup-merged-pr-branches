#!/usr/bin/env bash
#
# reqs: realpath
# TODO pass GCMPB_VERBOSE around instead of global

set -Eeuo pipefail
# TODO better way to handle this for now just skip to prevent issues
if shopt | grep -q 'inherit_errexit'; then
  shopt -s inherit_errexit
fi

if [ -z "${BASH_SOURCE[0]:-}" ]; then
  # zsh
  GCMPB_DIR="${0:A:h}"
  # shellcheck disable=SC2034
  IS_ZSH=1
else
  if ! command -v realpath >/dev/null 2>&1; then
    exit 1
  fi
  GCMPB_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
  # shellcheck disable=SC2034
  IS_BASH=1
fi

RED=$'\e[0;31m'
YELLOW=$'\e[1;33m'
CLEAR_COLOR=$'\e[0m'

printerr() { printf "\033[0;31m%s\033[0m\n" "$*" >&2; }
printverbose() {
  local verbose="${1}"
  local rest="${*:2}"
  if [ "${verbose}" = 'true' ]; then
    printf "\n\033[0;93m%s\033[0m\n" "${rest}" >&2
  fi
}

global_config_file_path() {
  printf '%s' "${XDG_CONFIG_HOME:-$HOME}/.config/gcmpb"
}

config_file_path() {
  printf '%s' "$(git rev-parse --git-dir)/info/gcmpb"
}

config() {
  local -r config_filepath="$(config_file_path)"
  if [ -f "${config_filepath}" ]; then
    # shellcheck disable=SC2086
    cat ${config_filepath}
  else
    printf ''
  fi
  local -r global_config_filepath="$(global_config_file_path)"
  if [ -f "${global_config_filepath}" ]; then
    # shellcheck disable=SC2086
    cat ${global_config_filepath}
  else
    printf ''
  fi
}

run_on_first_move_to_newly_created_branch_config_value() {
  (config | grep 'run_on_first_move_to_newly_created_branch=' || [[ $? == 1 ]]) | head -n 1 | cut -d'=' -f2
}

should_run_on_first_move_to_newly_created_branch() {
  local -r run_on_first_move_to_newly_created_branch="$(run_on_first_move_to_newly_created_branch_config_value)"
  if [ -n "${run_on_first_move_to_newly_created_branch}" ]; then
    printf '%s' "${run_on_first_move_to_newly_created_branch}"
  else
    printf 'false'
  fi
}

ignore_cleaning_branches_config_value() {
  (config | grep 'ignore_cleaning_branches=' || [[ $? == 1 ]]) | head -n 1 | cut -d'=' -f2
}

time_buffer_config_value() {
  (config | grep 'time_buffer=' || [[ $? == 1 ]]) | head -n 1 | cut -d'=' -f2
}

time_buffer() {
  local -r time_buffer="$(time_buffer_config_value)"
  if [ -n "${time_buffer}" ]; then
    if printf '%s' "${time_buffer}" | grep -q -E "\d+"; then
      printf '%s' "${time_buffer}"
    else
      printerr "time_buffer config vaule of:'${time_buffer}' does not match \d+"
    fi
  else
    printf '120'
  fi
}

# TODO remove get_ prefix
get_branches() {
  local ignore_cleaning_branches="${1:-}"
  local -r current_branch="$(git branch --show-current)"
  local -r current_remote_branch_parse="$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>&1)"
  local -r get_current_branch_result="$?"
  if [[ "${current_remote_branch_parse}" == "fatal: no upstream configured for branch"* ]]; then
    local current_branch_with_remote=":${current_branch}"
  else
    if [ "${get_current_branch_result}" = '0' ]; then
      local current_branch_with_remote="${current_remote_branch_parse}:${current_branch}"
    else
      printerr "${current_remote_branch_parse}"
      exit 1
    fi
  fi
  local -r remotes="$(git remote)"
  if [ -n "${remotes}" ]; then
    local -r default_remote="$(git remote | head -n1)"
    local -r default_branch="$(git ls-remote --symref "${default_remote}" HEAD | grep 'ref' | cut -d'/' -f3 | cut -d$'\t' -f1)"

    if [ "${ignore_cleaning_branches}" = "" ]; then
      ignore_cleaning_branches=" "
    fi

    local -r branches_to_check="$(git for-each-ref --format='%(upstream:short):%(refname:short)' refs/heads/ | grep -Ev '^:' | grep -v "${current_branch_with_remote}" |
      grep -v "${default_remote}/${default_branch}" | grep -v -E "${ignore_cleaning_branches}")"
    printf '%s\n' "${branches_to_check}"
  else
    printf '\n'
  fi
}

join_by() {
  local d=${1-} f=${2-}
  printf %s "${f//$'\n'/$d}"
}

available_platforms() {
  local dir="${1}"
  printf "%s" "$(join_by '|' "$(find "${dir}" -mindepth 1 -maxdepth 1 -exec basename {} \; | cut -d '.' -f1 | sort)")"
}

# TODO be more strict about url parsing
query_vcs_platform() {
  local -r remote="${1}"
  local -r platforms_available="${2}"
  local -r platform="$(git remote -v | grep 'push' | grep -E "^${remote}" | cut -d$'\t' -f2- | grep -o -E "${platforms_available}" | head -n1)"
  if [ -z "${platform}" ]; then
    # shellcheck disable=SC2016
    printf '%s:%s' 'not_found:platform not found from `git remote -v`' "${platforms_available}"
  else
    printf '%s' "found:${platform}"
  fi
}

spin() {
  local empty_or_message="${1:-}"
  local -r spinner='⣾⣽⣻⢿⡿⣟⣯⣷'
  local -r charwidth=1

  local message=""
  if [ -n "${empty_or_message}" ]; then
    message="${empty_or_message} "
  fi

  local i=0
  while true; do
    i=$(((i + 1) % ${#spinner}))
    printf "\r%s" "${message}${spinner:$i:$charwidth} "
    sleep 0.1
  done
}

kill_spinner_if_running() {
  local spinner_pid="${1}"
  if kill -s 0 "${spinner_pid}" >/dev/null 2>&1; then
    kill "${spinner_pid}" >/dev/null 2>&1
  fi
}

detect_pruneable() {
  read -r -a pruneable_remotes <<<"$(git remote)"
  if [ -n "${pruneable_remotes[*]}" ]; then
    # shellcheck disable=SC2046
    git remote prune -n "${pruneable_remotes[@]}"
  else
    printf ''
  fi
}

clean_pr_merged_branches() {
  local branches_to_check="${1}"
  local auto_apply="${2:-false}"
  local verbose="${3:-}"
  local spinner="${4:-true}"
  # TODO rename to to_delete
  local toDelete=()
  local dangling=()
  local -r platforms_available="$(available_platforms "${GCMPB_DIR}/platforms")"
  local spinner_pid=""
  if [ "${spinner}" = "true" ]; then
    (
      set +x
      spin 'checking for dead branches'
    ) &
    spinner_pid=$!
    # shellcheck disable=SC2064
    trap "kill_spinner_if_running '${spinner_pid}'" EXIT
  fi
  for remote_name in $(printf '%s' "${branches_to_check}" | cut -d '/' -f1 | uniq); do
    local remote_group='' platform_query_result='' platform='' platform_query_discrete='' platform_loaded=''
    remote_group="$(printf '%s' "${branches_to_check}" | grep "^${remote_name}")"
    platform_query_result="$(query_vcs_platform "${remote_name}" "${platforms_available}")"

    platform_query_discrete="$(cut -d':' -f1 <<<"${platform_query_result}")"
    if [ "${platform_query_discrete}" = "not_found" ]; then
      kill_spinner_if_running "${spinner_pid}"
      printf '%s\n%s' "${platform} in ${GCMPB_DIR}/platforms/" "$(ls "${GCMPB_DIR}/platforms/")"
      exit 22
    fi

    platform="$(cut -d':' -f2 <<<"${platform_query_result}")"
    local platform_path="${GCMPB_DIR}/platforms/${platform}.sh"
    if [ "${platform_loaded}" != "${platform}" ]; then
      platform_loaded="${platform}"
    fi

    decisions="$(decide_remote_group "${platform_path}" "${remote_group}" "${spinner_pid}" "${verbose}")"
    for base64_decision in ${decisions}; do
      local decision='' local_branch=''
      decision="$(base64 -d <<<"${base64_decision}")"
      local_branch="$(printf '%s' "${decision}" | cut -d':' -f2 -z | tr -d '\0')"
      printverbose "${verbose}" "${decision}"
      decision_command="$(printf '%s' "${decision}" | cut -d':' -f1 -z | tr -d '\0')"
      if [ "${decision_command}" = "${DECIDE_DELETE}" ]; then
        toDelete[${#toDelete[@]}]="${local_branch}"

      elif [ "${decision_command}" = "${DECIDE_WARNING_DELETED_ON_REMOTE}" ]; then
        dangling[${#dangling[@]}]="${local_branch}"
      fi
    done
  done

  local -r pruneable="$(detect_pruneable)"

  if [ ${#toDelete[@]} -gt 0 ] || [ ${#dangling[@]} -gt 0 ] || [ -n "${pruneable}" ]; then
    kill_spinner_if_running "${spinner_pid}"
    print_menu "${pruneable}" "${toDelete[@]}" "|" "${dangling[@]}"
    handle_plan "${auto_apply}" "${force_interactive}" "${toDelete[@]}" "|" "${dangling[@]}"
  else
    kill_spinner_if_running "${spinner_pid}"
  fi
  printf '\n'
  post_run "${platform_path}"
}

print_menu() {
  local -r pruneable="${1}"
  local items=("${@:2}")
  local index=0
  for item in "${items[@]}"; do
    if [ "${item}" == "|" ]; then
      break
    fi
    ((++index))
  done

  printf '\n%s\n' '==='
  if [ ${#toDelete[@]} -gt 0 ]; then
    printf '%s\n' "${RED}The following had PR's and can be deleted"
    printf '%s' "- "
    array_join '\n- ' "${toDelete[@]}"
    printf '\n'
  else
    printf '%s\n' "${RED}Did not find any branches with already merged/closed PRs"
  fi
  if [ -n "${pruneable}" ]; then
    printf '%s\n' "- Prune tracking branches"
    printf '%s\n' "${pruneable}" | grep -E '^\s\*'
  fi
  printf '%s' "${CLEAR_COLOR}"
  if [ ${#dangling[@]} -gt 0 ]; then
    printf '%s\n' "${YELLOW}The following were deleted on remote, but did not have a pr and will only be deleted if 'i' is entered"
    printf '%s' '~ '
    array_join '\n~ ' "${dangling[@]}"
    printf '%s\n' "${CLEAR_COLOR}"
  fi
}

DECIDE_DELETE='delete'
DECIDE_WARNING_DELETED_ON_REMOTE='warning_deleted_on_remote'
DECIDE_SKIP='skip'

decide_remote_group() {
  local platform_path="${1}"
  local remote_group="${2}"
  local spinner_pid="${3}"
  local verbose="${4}"
  #shellcheck source=/dev/null
  . "${platform_path}"

  for remote_branch_and_local_branch in $remote_group; do
    local remote_branch='' local_branch='' decided=''
    remote_branch="$(echo "${remote_branch_and_local_branch}" | cut -d':' -f1)"
    local_branch="$(echo "${remote_branch_and_local_branch}" | cut -d':' -f2)"

    decided="$(decide "${local_branch}" "${remote_branch}" "${spinner_pid}" "${verbose}")"
    printf '%s\n' "$(printf '%s' "${decided}" | base64 -w 0)"
  done
}

decide() {
  local -r local_branch="${1}"
  local -r remote_branch="${2}"
  local -r spinner_pid="${3}"
  local -r verbose="${4:-false}"

  local -r type_result="$(type pre_init_hook 2>&1)"
  if ! (printf '%s' "${type_result}" | grep -sq 'not found'); then
    pre_init_hook "${spinner_pid}"
  fi

  local -r states="$(get_states "${remote_branch}")"

  local -r had_a_pr="$(printf '%s\n' "${states}" | jq '. | length > 0')"
  if [ "${had_a_pr}" = "true" ]; then
    get_decision_on_branch_with_pr "${local_branch}" "${remote_branch}" "${states}"
  else
    get_decision_on_branch_without_pr "${local_branch}" "${remote_branch}" "${states}"
  fi
}

get_decision_on_branch_without_pr() {
  local local_branch="${1}"
  local remote_branch="${2}"
  local -r states="${3}"

  local deleted_remotely="false"
  local -r remotely_deleted_type_result="$(type branch_was_deleted_remotely 2>&1)"
  if ! (printf '%s' "${remotely_deleted_type_result}" | grep -sq 'not found'); then
    deleted_remotely="$(branch_was_deleted_remotely "${remote_branch}")"
  fi
  if [ "${deleted_remotely}" = "true" ]; then
    decide_print "${DECIDE_WARNING_DELETED_ON_REMOTE}" "${local_branch}" "${local_branch}->${remote_branch} never had a pr, but was deleted on remote" "${states}"
  else
    decide_print "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} never had a pr, not deleting" "${states}"
  fi
}

get_decision_on_branch_with_pr() {
  local -r local_branch="${1}"
  local -r remote_branch="${2}"
  local -r states="${3}"

  local -r any_open_statuses="$(get_any_open_states "${states}")"
  if [ "${any_open_statuses}" = "false" ]; then
    local only_completed=""
    only_completed="$(get_only_completed "${states}")"
    if [ "${only_completed}" = "true" ]; then
      decide_print "${DECIDE_DELETE}" "${local_branch}" "${local_branch}->${remote_branch} had a pr that completed" "${states}"
    else
      decide_print "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} has a pr that is not marked as ${COMPLETED_STATES}, not deleting" "${states}"
    fi
  else
    decide_print "${DECIDE_SKIP}" "${local_branch}" "${local_branch}->${remote_branch} has open pr's, not deleting" "${states}"
  fi
}

decide_print() {
  local -r action="${1}"
  local -r local_branch="${2}"
  local -r message="${3}"
  local -r states="${4}"
  printf '%s:%s:%s:%s' "${action}" "${local_branch}" "${message}" "${states}"
}

array_join() {
  local -r delimiter="${1}"
  local array=("${@:2}")
  local -r size="${#array[@]}"
  if [ "${size}" -gt 1 ]; then
    local index=0
    for item in "${array[@]}"; do
      if [ "${index}" = $((size - 1)) ]; then
        printf '%s' "${item}"
      else
        printf "%s${delimiter}" "${item}"
      fi
      ((++index))
    done
  else
    printf '%s' "${array[0]}"
  fi
}

ask() {
  local -r question="${1}"
  local -r force_interactive="${2:-true}"
  local apply='n'
  local init_interactive
  local -r tty_value="$(tty)"

  if [[ "${-}" =~ 'i' ]]; then
    init_interactive=true
  else
    init_interactive=false
    if [[ "${force_interactive}" = "true" ]]; then
      exec </dev/tty
    fi
  fi
  if [ "${IS_ZSH:-}" ]; then
    # shellcheck disable=SC2229
    read -r "?${question}" apply
  else
    read -rp "${question}" apply
  fi
  if [ "${init_interactive}" = "false" ]; then
    if [ "${tty_value}" = "not a tty" ]; then
      exec <&-
    else
      exec <"${tty_value}"
    fi
  fi
  printf "%s" "${apply}"
}

handle_plan() {
  local -r auto_apply="${1}"
  local -r force_interactive="${2}"
  local items=("${@:3}")
  local index=0
  for item in "${items[@]}"; do
    if [ "${item}" == "|" ]; then
      break
    fi
    ((++index))
  done

  local -r plan_to_delete=("${items[@]:0:$index}")
  local -r dangling=("${items[@]:$(($index + 1))}")

  local apply='_'
  local -r verbose="${GCMPB_VERBOSE:-}"
  if [ "${auto_apply}" = "true" ]; then
    apply='y'
  else
    while [[ "ynpi" != *"${apply}"* ]]; do
      apply="$(ask 'apply changes? (y,n,p,i,h,?) ' "${force_interactive}")"
      if [[ "h?" == *"${apply}"* ]]; then
        interactive_help
      fi
    done
  fi

  if [ "${apply}" = "_" ]; then
    apply='n'
  fi

  if [ "${apply}" = "y" ]; then
    apply_plan "${plan_to_delete[@]}"
  elif [ "${apply}" = "i" ]; then
    delete_branches "$(echo "${plan_to_delete[@]}" "${dangling[@]}" | tr "\n" " " | tr -s " ")"
  elif [ "${apply}" = "p" ]; then
    apply_partial "${verbose}" "${force_interactive}" "${items[@]}"
  fi
}

apply_plan() {
  local to_delete=("${@}")
  if [ "${#to_delete[@]}" -gt 0 ]; then
    delete_branches "$(echo "${to_delete[@]}" | tr "\n" " " | tr -s " ")"
  fi
  local -r all_remotes="$(git remote -v | cut -d$'\t' -f1 | uniq | tr $'\n' ' ')"
  # shellcheck disable=SC2086
  local -r pruneable="$(git remote prune -n ${all_remotes})"
  if [ -n "${pruneable}" ]; then
    local pruneable_remotes=()
    for remote_name in ${all_remotes}; do
      if printf '%s' "${pruneable}" | grep -q "would prune] ${remote_name}/"; then
        pruneable_remotes[${#pruneable_remotes[@]}]="${remote_name}"
      fi
    done
    prune_tracking "${pruneable_remotes[*]}"
  fi
}

apply_partial() {
  local -r verbose="${1}"
  local -r force_interactive="${2}"
  local -r items=("${@:3}")

  for branch in "${items[@]}"; do
    if [ "${branch}" = "|" ]; then
      continue
    fi
    local -r should_delete="$(ask "${branch}:delete? (y/n)" "${force_interactive}")"
    if [ "${should_delete}" = "y" ]; then
      delete_branches "${branch}"
    else
      printverbose "${verbose}" "not deleting...${branch}"
    fi
  done
  local -r all_remotes="$(git remote -v | cut -d$'\t' -f1 | uniq | tr $'\n' ' ')"
  # shellcheck disable=SC2086
  local -r pruneable="$(git remote prune -n ${all_remotes})"
  if [ -n "${pruneable}" ]; then
    local pruneable_remotes=()
    for remote_name in ${all_remotes}; do
      if printf '%s' "${pruneable}" | grep -q "would prune] ${remote_name}/"; then
        pruneable_remotes[${#pruneable_remotes[@]}]="${remote_name}"
      fi
    done
    interactive_prune_tracking "${verbose}" "${pruneable_remotes[*]}" "${force_interactive}"
  fi
}

interactive_prune_tracking() {
  local -r verbose="${1}"
  local -r remotes_to_prune="${2}"
  local -r force_interactive="${3:-true}"
  local -r prune="$(ask "prune tracking? (y/n)" "${force_interactive}")"
  if [ "${prune}" = 'y' ]; then
    prune_tracking "${remotes_to_prune}"
  else
    printverbose "${verbose}" "not deleting...${branch}"
  fi
}

prune_tracking() {
  local -r remotes_to_prune="${1}"
  git remote prune "${remotes_to_prune}"
}

delete_branches() {
  local -r branches=("$@")
  # shellcheck disable=SC2068
  git branch -D ${branches[@]}
}

post_run() {
  local -r platform_path="${1}"
  #shellcheck source=/dev/null
  . "${platform_path}"
  local -r type_result="$(type post_run_hook 2>&1)"
  if ! (printf '%s' "${type_result}" | grep -sq 'not found'); then
    post_run_hook
  fi
}

# TODO rename help_for_interactive
interactive_help() {
  # shellcheck disable=SC2006
  cat <<-'EOS'
  Interactive options: (case sensitive)
      y: yes
      n: no
      i: include dangling
      p: partial, same as in `git add -p` https://git-scm.com/docs/git-add#Documentation/git-add.txt--p
    h,?: print this help
EOS
}

default_usage_string() {
  cat <<-'EOS'
usage: git-cleanup-merged-pr-branches $PREVIOUS_SHA $NEXT_SHA $BRANCHES_OR_FILES | git-cleanup-merged-pr-branches help'
    All arguments are required however the first two can be empty strings.
    "...the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0)."
    Further explanation of arguments is here https://git-scm.com/docs/githooks#_post_checkout
EOS
}

standalone_usage_string() {
  printf "%s\n" "usage: git-cleanup-merged-pr-branches |  git-cleanup-merged-pr-branches help|--help|?|--?"
}

help() {
  local -r standalone="${1:-false}"
  if [ "${standalone}" = "true" ]; then
    standalone_usage_string
  else
    default_usage_string
  fi
  interactive_help
  cat <<-'EOS'
  Variables:
  SKIP_CLEANUP_MERGED_PR_BRANCHES: if set to true this script will skip execution
    GCMPB_VERBOSE: if set to true this script will print more information as it runs
EOS
}

cache_filepath() {
  local -r info_dir="$(git rev-parse --git-dir)/info"
  mkdir -p "${info_dir}"
  local -r cache_file="${info_dir}/gcmpb.cache"
  touch "${cache_file}"
  printf '%s' "${cache_file}"
}

cache_file() {
  cat "$(cache_filepath)"
}

save_current_run_time_to_cache() {
  local -r filepath="$(cache_filepath)"
  printf '%s' "$(cache_file | grep -v 'last_ran_at=' || [[ $? == 1 ]])" >"${filepath}"
  printf 'last_ran_at=%s\n' "$(date +%s)" >>"${filepath}"
}

get_last_run_time() {
  (cache_file | grep 'last_ran_at=' || [[ $? == 1 ]]) | head -n 1 | cut -d'=' -f2
}

is_past_buffer_time() {
  local -r buffer_time_override="${1:-}"
  local -r last_run_time="$(get_last_run_time)"
  if [ "${buffer_time_override}" = "0" ]; then
    printf 'true'
  else
    if [ -z "${last_run_time}" ]; then
      save_current_run_time_to_cache
      printf 'false'
    else
      local -r time_buffer_value="$(time_buffer)"
      if ((($(date +%s) - last_run_time) > time_buffer_value)); then
        printf 'true'
      else
        printf 'false'
      fi
    fi
  fi
}

CLONE_SHA='0000000000000000000000000000000000000000'
GIT_CHECKOUT_FILES='FILES'
GIT_CHECKOUT_BRANCHES='BRANCHES'

GIT_CHECKOUT_BRANCHES_OR_FILES=("${GIT_CHECKOUT_FILES}" "${GIT_CHECKOUT_BRANCHES}")

should_run() {
  local -r skip_cleanup_merged_pr_branches="${1}"
  local -r git_terminal_prompt_raw="${2}"
  local -r branch_or_files="${3}"
  local -r interactive_rebase_in_progress="${4}"
  local -r previous_sha="${5}"
  local -r next_sha="${6}"
  local -r run_on_first_move_to_newly_created_branch="${7}"
  local -r buffer_time_override="${8}"
  local -r manually_called="${9}"

  if [ "${skip_cleanup_merged_pr_branches}" = "true" ]; then
    printf 'false:skip_env_variable_set'
  elif [ "${interactive_rebase_in_progress}" = "true" ]; then
    printf 'false:interactive_rebase_is_in_progress'
  elif [ "${manually_called}" = "true" ]; then
    printf 'true:manually_called'
  elif [ "${git_terminal_prompt_raw}" = "0" ]; then
    printf 'false:git_terminal_prompt_set_to_zero'
  elif [ "$(is_past_buffer_time "${buffer_time_override}")" = "false" ]; then
    printf 'false:not_past_buffer_time'
  else
    if [ "$(new_branch "${branch_or_files}" "${previous_sha}" "${next_sha}")" = "true" ]; then
      if [ "${run_on_first_move_to_newly_created_branch}" = "true" ]; then
        save_current_run_time_to_cache
        printf 'true'
      else
        printf 'false:run_on_first_move_to_newly_created_branch_set_to_false'
      fi
    else
      if [ "${previous_sha}" = "${CLONE_SHA}" ]; then
        printf 'false:newly_cloned_repo'
      else
        if [ "${branch_or_files}" = "${GIT_CHECKOUT_BRANCHES}" ]; then
          save_current_run_time_to_cache
          printf 'true'
        else
          printf 'false:checking_out_files'
        fi
      fi
    fi
  fi
}

is_in_git_repo() {
  git rev-parse --is-inside-work-tree 2>/dev/null || printf '%s\n' 'false' # \n is to match format of rev-parse
}

# TODO rename to is_new_branch
new_branch() {
  local -r branch_or_files="${1}"
  local -r previous_sha="${2}"
  local -r next_sha="${3}"
  if [ "${branch_or_files}" = "${GIT_CHECKOUT_FILES}" ]; then
    printf 'false'
  else
    local -r moved_here_how_many_times="$(git reflog | grep "checkout: moving from " | grep -c "to $(git branch --show-current)")"
    if [ "${previous_sha}" = "${next_sha}" ] && [ "${moved_here_how_many_times}" = "1" ]; then
      printf 'true'
    else
      printf 'false'
    fi
  fi
}

branches_or_files_to_const() {
  local -r raw="${1}"
  printf '%s' "${GIT_CHECKOUT_BRANCHES_OR_FILES[$raw]}"
}

int_to_bool() {
  local -r int="${1}"
  if [ "${int}" = "0" ]; then
    printf "false"
  else
    printf "true"
  fi
}

run() {
  local previous_sha="${1}"
  local next_sha="${2}"
  local branch_or_files_raw="${3}"
  local auto_apply="${4:-false}"
  local skip_cleanup_merged_pr_branches="${5:-false}"
  local git_terminal_prompt_raw="${6:-1}"
  local verbose="${7:-false}"
  local spinner="${8:-true}"
  local buffer_time_override="${9:-}"
  local manually_called="${10:-false}"
  local interactive_rebase_in_progress=false
  local -r force_interactive=true

  if [ "$(is_in_git_repo)" = "true" ]; then
    local -r branches_or_files="$(branches_or_files_to_const "${branch_or_files_raw}")"

    if find -L "$(git rev-parse --git-dir)" -mindepth 1 | grep -iE 'rebase.*interactive' >/dev/null 2>&1; then
      interactive_rebase_in_progress=true
    fi

    local -r ignore_cleaning_branches="$(ignore_cleaning_branches_config_value)"

    if [ "${ignore_cleaning_branches}" != "" ]; then
      printverbose "${verbose}" "Branches ignored from cleaning via config($(config_file_path)):${ignore_cleaning_branches}:"
    fi
    local -r should_run_on_first_move_to_newly_created_branch_result="$("${manually_called}")"
    local -r should_run_result="$(should_run "${skip_cleanup_merged_pr_branches}" "${git_terminal_prompt_raw}" \
      "${branches_or_files}" "${interactive_rebase_in_progress}" "${previous_sha}" "${next_sha}" \
      "${should_run_on_first_move_to_newly_created_branch_result}" "${buffer_time_override}" "${manually_called}")"
    local -r should_run_bool="$(printf '%s' "${should_run_result}" | cut -d ':' -f1)"
    local -r should_not_run_reason="$(printf '%s' "${should_run_result}" | cut -d ':' -f2)"
    if [ "${should_run_bool}" = "true" ]; then
      clean_pr_merged_branches "$(get_branches "${ignore_cleaning_branches}")" "${auto_apply}" "${verbose}" "${force_interactive}" "${spinner}"
    else
      printverbose "${verbose}" "${should_not_run_reason}"
    fi
  else
    printf '%s\n' 'cannot determine if in a git repo'
  fi
}
